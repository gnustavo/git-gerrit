#!/usr/bin/env perl
# PODNAME: git-gerrit
# ABSTRACT: Git extension to implement a Gerrit workflow

use utf8;
use 5.010;
use strict;
use warnings;

use App::GitGerrit qw/run/;

return 1 if caller;

exit run();

__END__

=encoding utf8

=head1 SYNOPSIS

    git gerrit new         [--update] [--onto COMMIT] TOPIC [BRANCH]
    git gerrit push        [--prune] [--force] [--[no]rebase] [--draft] [--submit] \
                           [--base BASE] [--topic TOPIC] [--reviewer USER] [--cc USER]

    git gerrit list
    git gerrit update      [--patchsets] [--[no]prune] [--offline]
    git gerrit prune       [--offline]
    git gerrit checkout    [--update]
    git gerrit merge       [--update]

    git gerrit query       [--limit LIMIT] [--verbose] [[NAME=]QUERY]*
    git gerrit my          [--limit LIMIT] [--verbose] [changes|closed|drafts|watched|starred]
    git gerrit show        [--verbose] [CHANGE ...]

    git gerrit fetch       [CHANGE ...]
    git gerrit upstream    [--prune]
    git gerrit cherry-pick [--edit] [--no-commit] [CHANGE ...]

    git gerrit rebase

    git gerrit reviewer    [--add USERS] [--confirm] [--delete USERS] [CHANGE ...]
    git gerrit review      [--message TEXT] [[LABEL]=VOTE]* [CHANGE ...]
    git gerrit abandon     [--message TEXT] [CHANGE ...]
    git gerrit restore     [--message TEXT] [CHANGE ...]
    git gerrit revert      [--message TEXT] [CHANGE ...]
    git gerrit submit      [--no-wait-for-merge] [CHANGE ...]

    git gerrit web         [OPTIONS --] [CHANGE ...]

    git gerrit config
    git gerrit version

=head1 DESCRIPTION

Git-gerrit is a Git extension to manage changes using L<Gerrit Code
Review|http://code.google.com/p/gerrit/>.

Git-gerrit offers a rich set of sub-commands to make it easy to
create, query, amend, review, and submit changes to Gerrit, making it
possible to interact with it through the command-line, avoiding its
web interface most of the time and improving your efficiency. The goal
is to make Gerrit's review process feel like a natural extension of
Git.

Git-gerrit provides three main features:

=over

=item * An easy and safe way to push changes to Gerrit through the B<git
gerrit push> sub-command, avoiding the need to type remote names and long
refspecs.

=item * A standard way to map Gerrit changes into local branches, referred to
as "change-branches", making it easier to manage several changes simultaneously and
to perform the fetch-amend-push review cycle.

=item * Several sub-commands to query and inspect Gerrit changes and also to
review and submit them.

=back

Git-gerrit is implemented on top of L<Gerrit's REST
API|https://gerrit-review.googlesource.com/Documentation/rest-api.html>, which
was consolidated in its version 2.6. As this API matures, expect git-gerrit to
incorporate new functionality.

There are a few alternatives to git-gerrit described L<below|/"SEE ALSO">.

=head1 GLOSSARY

There are a few concepts that should be clear in order to the sub-commands
documentation below to make sense.

=over

=item B<change>

Each commit pushed to one of Gerrit's virtual branches (C<refs/for> or
C<refs/drafts>) creates a C<change> for review.

=item B<Change-Id>

A
L<Change-Id|https://gerrit-review.googlesource.com/Documentation/user-changeid.html>
is a 40-hexadecimal characters long SHA-1 hash prefixed with an C<I>. It
uniquely identifies a change and is normally generated by the C<commit-msg>
hook and inserted in the commit message footer.

=item B<{change-id}>

A
L<{change-id}|https://gerrit-review.googlesource.com/Documentation/rest-api-changes.html#change-id>,
is a more general identifier used by Gerrit's REST API to uniquely identify a
change . It can be expressed in one of three forms:

=over

=item * As an ID of the change in the format "<project>~<branch>~<Change-Id>",
where, for the branch, the C<refs/heads/> prefix can be omitted (e.g.,
C<myProject~master~I8473b95934b5732ac55d26311a706c9c2bde9940>).

=item * As a C<Change-Id> if it uniquely identifies one change (e.g.,
C<I8473b95934b5732ac55d26311a706c9c2bde9940>).

=item * As a legacy numeric change ID (e.g., C<4247>).

=back

You may pass any form of change-id to git-gerrit's sub-commands when they
require a CHANGE argument. Most commonly, you'll be using the legacy numeric
ID, just because it's more convenient.

=item B<upstream branch>

You normally should avoid creating changes directly on a local tracking
branch. Instead, you should create a local topic branch deriving from the
tracking branch to work on each change. We refer to the tracking branch from
which your topic branch derived as the topic's C<upstream branch>.

=item B<change-branch>

A C<change-branch> is a local branch with a special name that git-gerrit
creates and maps to a Gerrit change.

When the sub-command C<git gerrit new TOPIC BRANCH> starts a new change it
creates a topic branch named B<change/BRANCH/TOPIC>, which we call a
change-branch. We refer to BRANCH as the change-branch's C<upstream>, because
it is the branch from which the change-branch derives and to which it will be
ultimately merged back again.

When C<git gerrit update> or C<git gerrit fetch CHANGE> fetches an existing
change it creates a change-branch named B<change/BRANCH/ID>, where BRANCH is
the name of the branch associated with the change, and ID is its legacy
numeric change ID.

So, you should reserve the C<change/> top-level branch name for the
change-branches managed by git-gerrit.

=back

=head1 WORKFLOW

Here are the main use-cases of git-gerrit to manage your changes.

=head2 Creating a new change for review

Suppose you want to create a new change on master:

    git gerrit new topic master
    # edit
    git commit
    git gerrit push

First you create a new change-branch for your new change. If you're already in
master you don't need to mention it on the first line. Then you make your
change editing your working tree and committing. When you're done, simply tell
git-gerrit to push your change.

In order to do the same thing using only standard Git commands you'd do
something like this:

    git checkout master
    git pull --ff-only
    git checkout -b change/master/topic
    # edit
    git commit
    git push origin HEAD:refs/for/master

The first two commands guarantee that you're creating the change branch off of
an updated master. People usually don't do it just out of laziness, but
git-gerrit does it for you.

=head2 Studying changes

Usually you're want to study open changes that you own or that you've been
invited to review. The easiest way to get them all is this:

    git gerrit update

This queries Gerrit to grok all those open changes and fetch them all at once,
creating a change-branch for each of them and deleting change-branches of
already merged changes.

After updating the local repositoty, the 'update' command lists all
change-branches. If you just want to list them without updating (which may
take a few seconds) you may use the faster 'list' command:

    git gerrit list

This way you can easily study them using 'git show', e.g.:

    git show change/master/1234

Without git-gerrit you have to study the changes in the web interface or at
least get there the Git command to fetch the change before you can study it.

=head2 Reviewing a change

    git gerrit review =-1 1234

After having studied a change with 'git show' you may record your review with
the 'review' command identifying the change (e.g. 1234). If you omit the
change ID you'll be prompted to chose among all the change branches in your
local repository the one corresponding to the change you want to review.

Without git-gerrit you'd have to perform the review using Gerrit's web
interface.

=head2 Amending a change

    git gerrit checkout
    # edit
    git commit --amend
    git gerrit push

To amend a change you first checkout its change-branch. Of course, you may do
it with 'git checkout' specifying a change-branch. But the 'git gerrit
checkout' command prompts you with a list of all change-branches for you to
chose which one you'd like to checkout.

Then you can amend it and, finally, push it as another patchset to Gerrit.

What if you want to make a comment on your new patchset? No problem, simply
change the last line above to this:

    git gerrit push && git gerrit review

Without git-gerrit you would have to go first to Gerrit's web interface, find
the change, and copy its fetch/checkout command line. Then you could paste it
in your terminal and perform the amending like this:

    git fetch https://gustavo@gerrit.example.net/project refs/changes/90/1190/2 && git checkout FETCH_HEAD
    # edit
    git commit --amend
    git push origin HEAD:refs/for/master

Oh, and if you want to comment on the new patchset, you have to go to Gerrit's
web interface again.

=head2 Working on top of changes pending revision

You normally should try to push changes that are independent of each other,
because amending a change upon which others depend lead to a cascading rebase
problem. However, sometimes you want to start work on top of some changes
already pushed to Gerrit but that haven't been submitted yet. Git-gerrit's
C<cherry-pick> command can help you here. Suppose you pushed two changes
(e.g. 101 and 102) that you need to have integrated in order to start working
on another change. You may create a new change and cherry-pick those two
changes over it, creating a commit over which you can work. Like this:

    git gerrit new topic master
    git gerrit cherry-pick 101 102

Now you can start working on a future change and make another commit. At the
end, the C<change/master/topic> change-branch will have two commits. First the
one created by the cherry-pick and then the one you created by yourself. You
don't want to push it to Gerrit, though, while those changes are still being
reviewed. When they're finally submitted, you can pull them to C<master>,
rebase your change-branch on top of C<master> and push it to Gerrit. Like so:

    git gerrit update
    git gerrit rebase --tip
    git gerrit push

The 'update' sub-command updates every change-branch and also their upstream
branches. The 'rebase' sub-command usually simply rebases the change-branch
onto its upstream. With the C<--tip> option it rebases just the commit at the
tip of the change-branch onto its upstream, effectivelly discarding the commit
created previously with the 'cherry-pick' command.

=head1 SUB-COMMANDS

Each git-gerrit sub-command has its own set of options, described in its own
section below.

The options below, however, are accepted by all of them:

=over

=item B<--debug>

This option makes git-gerrit print to STDERR every system command (usually a
Git command) invoked and every Gerrit REST call made during the execution of
its sub-commands. System commands are prefixed with B<CMD:> and Gerrit REST
calls with B<GERRIT:>.

=item B<--help>

Shows git-gerrit's manpage and quits.

=item B<--noop>

This option is for "no operation". With it git-gerrit do not execute any
command that will change anything. This means, any Git command affecting your
working tree or any Gerrit REST call affecting the change status on the
server. Use it along with --debug to see what git-gerrit would do.

=back

Option names may be abbreviated to uniqueness, case does not matter, and a
single dash is sufficient, even for long option names.

Several sub-commands accept one or more change IDs as arguments. If you don't
pass any ID you'll be prompted with a menu of all change-branches
for you to chose from.

=head2 git gerrit new [--update] [--onto COMMIT] TOPIC [BRANCH]

The B<new> sub-command creates a new change-branch off of BRANCH called
C<change/BRANCH/TOPIC> and checks it out for you to start making changes to
your working tree.

The TOPIC name must contain at least one non-digit character so that it's
clear that this is a new change-branch, not yet pushed to Gerrit. Also, the
TOPIC name cannot contain slashes so that it's not confused with the branch
name. It's usually best to use only letters and hyphens.

If no BRANCH is specified, the new change is based on the current branch,
unless it's a change-branch itself, in which case the new change is based on
the change-branch's upstream branch.

=over

=item B<--update>

This option makes git-gerrit update BRANCH before creating the change-branch
by invoking the C<update> sub-command. This way you guarantee to start a
change on top of the newest state of your project, which is usually the right
thing to do.

=item B<--onto COMMIT>

This option specify a commit off of which the new branch is created. This may
be useful if you want to start new work off of a change branch not submitted
yet.

=back

You will be warned if your working tree is dirty, as this is sometimes a
mistake.

=head2 git gerrit push OPTIONS*

The B<push> sub-command should be invoked to push a change-branch to Gerrit's
C<refs/for/> branch associated with its upstream branch. It should be invoked
when you have the change-branch checked out in your working tree.

When a new change-branch is pushed it creates a Gerrit change associated with
the TOPIC in its name, as created by C<git gerrit new> above.

=over

=item B<--prune>

After pushing a change-branch, you don't really need to keep it any longer,
since you'll aways be able to fetch it later from Gerrit. This option tells
git-gerrit to checkout the upstream branch and to delete the just pushed
change-branch.

=item B<--force>

By default, git-gerrit refuses to push a change-branch unless it contains a
single commit dangling from its upstream and git status is clean (i.e., C<git
status --untracked-files=no> doesn't show any modification that hasn't been
added to the index). If either one of these conditions don't hold it dies with
an error message telling what's the problem. If you're sure you want to push
anyway, you can use this option. If both conditions don't hold, you'll have to
use the option twice.

It's best to avoid multiple commit pushes, because if you have to amend them
later, having multiple commits may require rebasing dependent commits, which
is a more complex operation and clutters the review history of the change.

If git status isn't clean, the the upstream isn't checked out.

=item B<--[no]rebase>

Before a brand new change-branch (one ending in a TOPIC C<name>) is pushed,
its upstream branch is updated and it is rebased on top of its upstream. This
is to make sure you're pushing a change based on the newest project state. If,
by any reason, you don't want to have it rebased, use the C<--norebase>
option.

A change-branch that has been checked out (one ending in an ID) isn't rebased
by default, because this would clutter the change review history in Gerrit. If
you want it rebased nonetheless, use the C<--rebase> option.

If git status isn't clean or if the commit being pushed is a merge commit it's
not rebased.

=item B<--draft>

This option makes git-gerrit push the change-branch to C<refs/drafts/UPSTREAM>
instead of to C<refs/for/UPSTREAM>, creating a draft change in Gerrit.

This option disables the invitation of automatic reviewers because drafts
aren't usually in good shape for formal review.

=item B<--submit>

This option tells Gerrit to L<auto-merge the change during
push|http://gerrit-documentation.googlecode.com/svn/Documentation/2.7/user-upload.html#auto_merge>,
which is a feature implemented in Gerrit 2.7.

=item B<--base BASE>

This option L<selects a new merge
base|http://gerrit-documentation.googlecode.com/svn/Documentation/2.7/user-upload.html#base>
for Gerrit, which is a feature implemented in Gerrit 2.7.

=item B<--topic TOPIC>

This option specifies another name for the topic that will be associated with
the change. By default, the topic name is the last component of the current
change-branch name, as specified by the C<git gerrit new> sub-command.

=item B<--reviewer USERS>

This option let's you invite a list of users to review your change.

USERS is a colon-separated list of usernames. You may also pass this option
more than once, to invite more than a set of users.

=item B<--cc USERS>

This option let's you notify a list of users about your change.

USERS is a colon-separated list of usernames. You may also pass this option
more than once, to invite more than a set of users.

=back

=head2 git gerrit list

(Command B<list> alias: C<ls>.)

The B<list> sub-command lists all existing change-branches in
your local repository in this format:

    change/master/2506    ea27239 [CDS-100] Testing
    change/master/2507  * c320795 [CDS-100] Remove .gitreview
    change/master/topic   ea27239 [CDS-100] Testing

=head2 git gerrit update [--[no]prune] [--offline]

(Command B<update> alias: C<up>.)

The B<update> sub-command creates and/or updates the local change-branches
associated with all open changes in Gerrit that you own or that you are a
reviewer of. It also deletes (i.e., prunes) any existing change-branch not
associated with an open change in Gerrit. At the end it invokes the B<list>
sub-command to show the updated references.

=over

=item B<--[no]prune>

By default, existing change-branches not associated with any
open change are pruned, unless you pass the C<--noprune> option.

=item B<--offline>

This avoids querying Gerrit and reuses the cached response from the previous
update. Since querying Gerrit can take a few seconds you may not want to wait
everytime. This may be useful if you invoked C<git gerrit prune> and changed
your mind.

=back

=head2 git gerrit prune [--offline]

The B<prune> sub-command prunes (i.e., deletes) every change-branch that
hasn't been changed locally, i.e., that points to any of the patchsets of the
corresponding change.

=over

=item B<--offline>

Use this option to avoid querying Gerrit and reuse the cached response from
the previous update/prune command.

=back

=head2 git gerrit query [--limit LIMIT] [--verbose] [[NAME=]QUERY]*

The B<query> sub-command let's you list Gerrit changes meeting specific
criteria. The matching changes are shown in tabular format, one change per
line, listing their legacy ID, status, Code-Review vote, time of last update,
project name, branch name, owner name, and subject line.

You may pass a list of queries. Each QUERY's results is presented separated
from the other by a empty line and a header containing the query's name and
expression inside brackets. For example:

    $ git gerrit query 'Starred changes=is:starred' is:draft

    [Starred changes=is:starred]
    ID    STATUS CR UPDATED    PROJECT    BRANCH OWNER          SUBJECT
    1186  MERGED +2 2013-09-18 helloworld master Gustavo Chaves [SB-1] Test amend 3

    [QUERY=is:draft]
    ID    STATUS CR UPDATED    PROJECT    BRANCH OWNER          SUBJECT
    1187  NEW       2013-09-08 helloworld master Gustavo Chaves [SB-2] Make foo

Note that unnamed queries are prefixed by C<QUERY=> instead of by their names.

Each QUERY can be specified by a L<Gerrit search
expression|https://gerrit-review.googlesource.com/Documentation/user-search.html>.

=over

=item B<--limit LIMIT>

This option put a limit on the number of changes that are shown for each
QUERY.

=item B<--verbose>

This option makes the change topic be shown inside parenthesis to the right of
the change branch name. This requires a separate REST call for each change,
making the result appear more slowly.

=back

=head2 git gerrit my [--limit LIMIT] [--verbose] [changes|closed|drafts|watched|starred]

The B<my> sub-command provides a set of pre-defined queries for the B<query>
sub-command. It's based on Gerrit's standard queries shown in its web
interface under the C<My> tab.

The C<changes> argument is used by default if you don't specify any.

The options taken by the C<my> sub-command are passed to the C<query>
sub-command like this:

=over

=item * B<changes>

    'Outgoing reviews=is:open+owner:self' \
    'Incoming reviews=is:open+reviewer:self+-owner:self'

=item * B<closed>

    'Recently closed=is:closed+owner:self+-age:1mon'

=item * B<drafts>

    'Drafts=is:draft'

=item * B<watched>

    'Watched changes=is:watched+status:open'

=item * B<starred>

    'Starred changes=is:starred'

=back

=head2 git gerrit show [--verbose] [CHANGE ...]

The B<show> sub-command describes one or more CHANGEs in detail, showing much
like what Gerrit shows in a change page of its web interface. For example:

    $ git gerrit show 1186
     Change-Num: 1186
      Change-Id: I0bb976fe1890657d7a1c3ba403e0b58ac2b63cd7
        Subject: [SB-1] Test amend 3
          Owner: Gustavo Chaves
        Project: helloworld
         Branch: master
        Created: 2013-09-18 16:22:21
        Updated: 2013-09-18 19:45:56
         Status: MERGED

    REVIEWER                         Code-Review
    Gustavo Leite de Mendonça Chaves  0
    Jenkins                          +1
    Laurel Keys                      +2
    ------------------------------------------------------------

If no CHANGE is specified, you'll be prompted to chose some.

=item B<--verbose>

This option makes git-gerrit to also display the change messages.

=head2 git gerrit fetch [CHANGE ...]

The B<fetch> sub-command fetches one or more CHANGEs from Gerrit and creates
change-branches pointing to them.

A Gerrit change may contain a series of patch-sets. The C<fetch> sub-command
fetches the current (latest) one. If there is already a change-branch for the
change, it will be updated to the change's current patch-set.

If no CHANGE is specified, you'll be prompted to chose some.

=head2 git gerrit checkout [--update]

(Command B<checkout> alias: C<co>.)

The B<checkout> sub-command prompts you to select an existing change-branch
to checkout.

=over

=item B<--update>

This option makes git-gerrit invoke the B<update> command before prompting the
user to select a reference.

=back

=head2 git gerrit merge [--update]

The B<merge> sub-command prompts you to select one or more existing
change-branches merge them all in a new branch created on the current
HEAD. The "merge branch" is called "merge/N+N+N+..." where the Ns are the IDs
of the changes associated with the merged change-branches.

=over

=item B<--update>

This option makes git-gerrit invoke the B<update> command before prompting the
user to select a reference.

=back

=head2 git gerrit upstream [--prune]

(Command B<upstream> alias: C<ups>.)

The B<upstream> sub-command should be invoked when you're in a
change-branch. It checks out the upstream branch.

=over

=item B<--prune>

This option deletes the original change-branch if it's associated with an
already pushed change, i.e., if its name ends in a legacy numeric id, not in a
topic name.

=back

=head2 git gerrit cherry-pick [--edit] [--no-commit] [CHANGE ...]

(Command B<cherry-pick> alias: C<pick>.)

The B<cherry-pick> sub-command invokes the B<fetch> sub-command to fetch a
list of CHANGES from Gerrit and to create local change-branches for them. Then
it applies all those changes to the current branch using the C<git
cherry-pick> command.

You may want to use this command to work on top of changes not submitted in
Gerrit yet. You can cherry-pick them on top of a scratch branch and then
continue to work on top of it while you wait for those changes to be reviewed.

=over

=item B<--edit>

If specified, this option is passed to C<git cherry-pick> to let you edit the
commit message.

=item B<--no-commit>

If specified, this option is passed to C<git cherry-pick> to avoid performing
any commits.

"This flag applies the changes necessary to cherry-pick each named commit to
your working tree and the index, without making any commit. In addition, when
this option is used, your index does not have to match the HEAD commit. The
cherry-pick is done against the beginning state of your index.

This is useful when cherry-picking more than one commits' effect to your index
in a row."

=back

=head2 git gerrit rebase [--tip]

The B<rebase> sub-command simply rebases the current change-branch onto its
upstream. It's a shortcut for C<git rebase UPSTREAM> but arguably easier
because you don't have to remember the upstream's name.

An error message is produced if it's invoked when HEAD isn't pointing to a
change-branch.

=over

=item B<--tip>

This option rebases just the commit at the tip of the change-branch onto its
upstream. It's useful to rebase a change created on top of some cherry-picked
commits after they have been merged on upstream.

=back

=head2 git gerrit reviewer [--add USERS] [--confirm] [--delete USERS] [CHANGE ...]

The B<reviewer> sub-command allows you to manage the list of reviewers for one
or more CHANGEs.

If no CHANGE is specified, you'll be prompted to chose some.

=over

=item B<--add USERS>

This option let's you invite new users to review the changes. You can pass a
comma-separated list of users and even use more than one C<--add> option.

You can use Gerrit groupnames in addition to usernames, if you want to invite
a group of users to review.

=item B<--confirm>

Gerrit may reject the addition of groups with too many users because it recons
you may be doing it by mistake. In this case, you'll receive an error message
something like this:

    "The group My Group has 15 members. Do you want to add them all as reviewers?"

If you really want to invite them all, try again with using the C<--confirm>
option.

=item B<--delete USERS>

This option let's you remove reviewers from the changes. You can pass a
comma-separated list of users and even use more than one C<--delete> option.

You can use Gerrit groupnames in addition to usernames, if you want to remove
a group of reviewers.

=back

After adding and removing reviewers, C<git gerrit reviewers> shows the
remaining list of reviewers of the changes.

=head2 git gerrit review [--message TEXT] [[LABEL]=VOTE]* [CHANGE ...]

The B<review> sub-command allows you to review (duh!) one or more CHANGEs by
casting votes and adding messages to them. If you want to be precise and add a
message, you should be reviewing a single change at a time, but sometimes it's
convenient to be able to cast the same vote to a set of changes.

If no CHANGE is specified, you'll be prompted to chose some.

You can cast multiple votes using C<LABEL=VOTE> arguments, where LABEL names a
Gerrit
L<label|https://gerrit-review.googlesource.com/Documentation/config-labels.html>
and VOTE is a negative, zero, or positive number. If you omit the LABEL name
(but not the equal sign!) you'll be voting in the standard C<Code-Review>
label.

The Git editor (see the definition of C<GIT_EDITOR> with the C<git help var>
command) is invoked for you to compose a message to be added to the review.

=over

=item B<--message TEXT>

This option adds a message to the review avoiding the Git editor invocation.

=back

=head2 git gerrit submit [--no-wait-for-merge] [CHANGE ...]

The B<submit> sub-command submits one or more approved CHANGEs, making Gerrit
merge them into their remote upstream branches.

If no CHANGE is specified, you'll be prompted to chose some.

=over

=item B<--no-wait-for-merge>

By default git-gerrit will wait for the merge of the changes into their
branches to complete in Gerrit. This option tells it not to wait and finish as
soon as it receives Gerrit's submit acknowledgment.

=back

=head2 git gerrit abandon [--message TEXT] [CHANGE ...]

The B<abandon> sub-command abandons one or more unmerged CHANGEs.

If no CHANGE is specified, you'll be prompted to chose some.

The Git editor  (see the definition of C<GIT_EDITOR> with  the C<git help var>
command) is invoked for you to compose a message to be added to the action.

=over

=item B<--message TEXT>

This option adds a message to the review avoiding the Git editor invocation.

=back

=head2 git gerrit restore [--message TEXT] [CHANGE ...]

The B<restore> sub-command restores one or more abandoned CHANGEs.

If no CHANGE is specified, you'll be prompted to chose some.

The Git editor (see the definition of C<GIT_EDITOR> with the C<git help var>
command) is invoked for you to compose a message to be added to the action.

=over

=item B<--message TEXT>

This option adds a message to the review avoiding the Git editor invocation.

=back

=head2 git gerrit revert [--message TEXT] [CHANGE ...]

The B<revert> sub-command reverts one or more already merged CHANGEs. Gerrit
does so by creating, in the server, for each CHANGE, a new change with an
inverted patch on top of the CHANGE remote upstream branch.

If no CHANGE is specified, you'll be prompted to chose some.

The Git editor (see the definition of C<GIT_EDITOR> with the C<git help var>
command) is invoked for you to compose a message to be added to the action.

=over

=item B<--message TEXT>

This option adds a message to the review avoiding the Git editor invocation.

=back

=head2 git gerrit web [OPTIONS --] [CHANGE ...]

The B<web> sub-command opens up in your browser Gerrit's web page for each
CHANGE. It does it by invoking C<git web--browse> for the list of URLs
associated with each CHANGE. If no CHANGE is specified, you'll be prompted to
chose some.

Every option (but --debug) is passed as-is to the C<git web--browse>
command. If you pass any option you must mark the end of them with a '--'
mark.

=head2 git gerrit config

The B<config> sub-command lists Git's configuration variables in the
C<git-gerrit> section. The variables C<remote>, C<baseurl>, and C<project> are
always shown, even if they're inferred and not explicitly configured.

=head2 git gerrit version

The B<version> sub-command shows the versions of git-gerrit, Git, and Gerrit
that you're using.

=head1 INSTALLATION

Git-gerrit requires Perl 5.10 or newer and Git (any version should do, but 1.8
is better integrated). Check it like this:

    perl -v
    git --version

Git-gerrit is part of the
L<App::GitGerrit|http://search.cpan.org/dist/App-GitGerrit/> distribution that
you have to download from L<CPAN|http://search.cpan.org/> and install. There
are a few ways to do it, depending on your environment. Here are a few tips:

=head2 If you cook your own Perl

If you build your own Perl, perhaps using L<perlbrew|http://perlbrew.pl/>, you
know the drill:

    cpanm App::GitGerrit

=head2 Debian, Ubuntu, etc.

If you want to use the Perl that comes packaged in your Debian-based
distribution, you can install some git-gerrit dependencies from packaged perl
modules. These are the ones packaged with Ubuntu 12.04:

    sudo apt-get install -y \
        liburi-encode-perl libhtml-tree-perl libjson-perl \
        libscope-guard-perl libcrypt-ssleay-perl libwww-perl cpanminus

The nifty C<cpanm> installer should take care of the remaining dependencies
and of installing C<git-gerrit> for you like this:

    sudo su -l -c "cpanm App::GitGerrit"

=head2 RedHat, CentOS, etc.

If you want to use the Perl that comes packaged in your RedHat-derived
distribution, you can install some git-gerrit dependencies from packaged Perl
modules. These are the ones packaged with CentOS 6.4:

    sudo yum install -y \
        perl-URI perl-HTML-Tree perl-JSON perl-Scope-Guard \
        perl-Test-Exception perl-Test-use-ok perl-Crypt-SSLeay perl-YAML \
        perl-CPAN perl-ExtUtils-MakeMaker

The verbose C<cpan> installer should take care of the remaining dependencies
and of installing C<git-gerrit> for you like this:

    sudo su -l -c "cpan App::GitGerrit"

=head2 Windows

On Windows I suggest that you install L<Strawberry
Perl|http://strawberryperl.com/>. Then, open a command line tool and type
this:

    cpanm Data::Util App::GitGerrit

Note that on Windows you may have to invoke C<git-gerrit> directly as
B<git-gerrit> and not through Git as B<git gerrit>. This is because Git will
probably use the old Perl that comes bundled with it, not Strawberry
Perl. Your mileage may vary, though.

=head1 CONFIGURATION

Git-gerrit is configured through Git's standard configuration framework, which
you can read about with the C<git help config> command. All git-gerrit's
configuration variables are in the C<git-gerrit> section and can be created at
the C<system>, the C<global>, or the C<local> level. More specifically,
git-gerrit groks its configuration from the output of the C<git config -l>
command.

=head2 Git and Gerrit access

In order to interact with Gerrit, git-gerrit has to know three things which it
can usually infer from your default Git configuration, but that you may be
explicit about using these Git configuration variables:

=over

=item * B<git-gerrit.remote>

Whenever git-gerrit invokes a Git command to interact with Gerrit (e.g.,
git-push and git-fetch) it refers to Gerrit using a remote name. You probably
already have a remote configured for Gerrit. If you don't, git-gerrit assumes
the name C<origin> by default.

You can check your Git remotes by issuing the command C<git remote -v>. Note
that the remote's URL must use the HTTP or (better yet) HTTPS protocol, not
SSH.

=item * B<git-gerrit.baseurl>

This is the value of the
L<gerrit.canonicalWebUrl|https://gerrit-review.googlesource.com/Documentation/config-gerrit.html#_a_id_gerrit_a_section_gerrit>
variable configured in the C<etc/gerrit.config> file at Gerrit's server. It's
needed so that git-gerrit can interact with Gerrit's REST API.

If you don't specify it, git-gerrit assumes that it is equal to the remote's
URL minus the path.

This usually can be configured globally, if you have a Gerrit server hosting
several of your repositories.

It's a good idea to have your username in this URL to avoid being asked for it
interactively.

=item * B<git-gerrit.project>

This is the name of the project associated with the Gerrit repository. It's
needed so that git-gerrit can interact with Gerrit's REST API.

If you don't specify it, git-gerrit assumes that it is equal to the path of
the remote's URL stripped of any path in C<git-gerrit.baseurl>.

=back

This is designed so that for most Gerrit instances git-gerrit should work out
of the box, without any explicit configuration.

For example, if you're working on Android's
L<kernel|https://android-review.googlesource.com/#/admin/projects/kernel/common>
project, you may clone it with the suggested command:

    git clone https://android.googlesource.com/kernel/common

Then, git-gerrit will figure this out from the clone URL:

    git-gerrit.remote = origin
    git-gerrit.baseurl = https://android.googlesource.com
    git-gerrit.project = kernel/common

If you're working on Eclipse's
L<egit|https://git.eclipse.org/r/#/admin/projects/egit/egit> project, however,
you must help git-gerrit figuring its configuration. This is the suggested
command to clone it:

    git clone https://git.eclipse.org/r/egit/egit

Note that the base URL has a path part (C</r>). So, in this case you must
configure it explicitly like this:

    git config --global git-gerrit.baseurl https://git.eclipse.org/r

The remote and the project names can be inferred automatically.

=head2 Option defaults

Each git-gerrit sub-command accept a specific set of options and each option
has a default value which is specified in the sub-commands documentation. You
can specify a default set of options for each sub-command by defining a
variable like this:

=over

=item * B<options.COMMAND> OPTIONS

OPTIONS is the option list that should be passed as default for
COMMAND. Specifically, it's a string which is split on spaces and the
resulting list is unshifted on @ARGV, so that it's like you have passed these
options on the command line first.

So, for example, if you'd like to always update the upstream branch when you
create a new change-branch, you can pass the C<--update> option to C<new> by
default by setting this:

    git config git-gerrit.options.new --update

Options common to all commands can be specified to the pseudo-command 'all'
like this:

    git config git-gerrit.options.all --debug

=back

=head2 Automatic reviewers

You can tell git-gerrit to invite automatically some users to review your
pushed changes based on their upstream branch name and on the files affected.

=over

=item * B<git-gerrit.reviewers USERS [CONDITION]*>

This variable specifies a list of Gerrit users to be automatically invited as
reviewers in a B<git gerrit push> command.

USERS is a colon-separated list of usernames.

CONDITIONs are space-separated boolean expressions. All CONDITIONs, if any,
must be true for USERS to be invited. If no CONDITIONS are specified, USERS
are invited.

A CONDITION may check either the name of the branch to which the change is
being pushed or the names of the files affected by the change itself. The
matching may be either exact or by L<regular expressions|perlre>, as follows.

=over

=item * branch=REFNAME

Checks if REFNAME is exactly equal to the change's upstream name (without the
C<refs/heads> prefix).

=item * branch~REGEXP

Checks if the upstream name matches REGEXP.

=item * path=PATH

Checks if the path of any file affected by the commit being pushed, as shown
by C<git diff --name-only upstream..HEAD> is exactly equal to the complete
path of one of those files.

=item * path~REGEXP

Checks if the path of any affected file matches REGEXP.

=back

You may specify the C<git-gerrit.reviewers> variable multiple times. All users
mentioned in all specifications that match their CONDITIONs are invited as
reviewers to the current change being pushed.

=back

The list of automatic reviewers is used only when pushing the first patchset
of a new change. Later patchsets of the same change don't clobber the list
of current reviewers because it may have been manually adjusted by the user.

=head1 COMMIT-MSG HOOK

Gerrit provides a C<commit-msg> hook for Git that should be installed in your
repositories. Its purpose is to insert a C<Change-Id> footer in the commit
messages so that Gerrit can discern independent commits from merely amended
ones.

Git-gerrit takes care of installing this hook for you. When you invoke its
C<new> or C<push> sub-commands, it checks to see if your repository already
has a C<commit-msg> hook installed. If not, it automatically downloads
Gerrit's standard hook and installs it for you.

=head1 AUTHENTICATION

If you have Git 1.8.0 or later, git-gerrit uses Git's credential management
system via its B<git-credential> command to obtain credentials for connecting
to Gerrit. You can take advantage of this by configuring Git's
C<credential.helper> variable to use a persistent credential storage and avoid
being asked for the authentication credentials repeatedly. Please, read
B<gitcredentials> manpage to know how to configure this system. But here are a
few tips anyway:

=over

=item * B<On Ubuntu Linux (tested on 13.04)>

Use the
L<git-credential-gnome-keyring|http://stackoverflow.com/questions/13385690/how-to-use-git-with-gnome-keyring-integration>
program which provides a very nice integration with your desktop
environment. You have to compile the helper first:

    sudo apt-get install libgnome-keyring-dev
    sudo make -C /usr/share/doc/git/contrib/credential/gnome-keyring
    git config --global credential.helper /usr/share/doc/git/contrib/credential/gnome-keyring/git-credential-gnome-keyring

=item * B<On other Unix-like systems>

The B<git-credential-cache> command which comes with Git is as a balanced
compromise between convenience and security:

    git config --global credential.helper cache --timeout 86400

=item * B<On Windows systems>

The best choice seems to be the third-party application
L<git-credential-winstore|http://gitcredentialstore.codeplex.com/>, which you
have to install first.

    git config --global credential.helper winstore

=back

If you're using a pre-1.8 Git that doesn't support the B<git-credential>
command, there are a few fall-backs.

First, git-gerrit tries to get credentials from the C<git-gerrit.baseurl>
configuration variable. The URL should be in a format like
C<https://username:password@host/path>. Security conscious people should avoid
putting credentials there, but if you do git-gerrit will be satisfied.

Then, git-gerrit tries to load Perl's L<Net::Netrc> module, if available, to
get credentials from a C<netrc(5)> file.

As a last resort, git-gerrit tries to load Perl's L<Term::Prompt> module to
prompt you for the credentials.

If none of this works, git-gerrit dies screaming.

=head1 BASH COMPLETION

If you use bash and have L<bash completion enabled for
Git|http://git-scm.com/book/en/Git-Basics-Tips-and-Tricks> you may also enable
it for git-gerrit by sourcing the F<etc/bash_completion.d/git-gerrit> script
that comes with L<App::GitGerrit> distribution. You may do it in your
F<~/.bashrc> file like this:

    source $PERL_ROOT/etc/bash_completion.d/git-gerrit

Where C<PERL_ROOT> is the root of your Perl installation.

=head1 SEE ALSO

There are some alternatives to git-gerrit, other Git extensions to make it
easier to interact with Gerrit. The ones mentioned below are the most well
known to the author.

=over

=item * L<git-review|https://github.com/openstack-infra/git-review>

Being the original inspiration for git-gerrit, git-review is a mature tool
that's used by some very well known projects, such as OpenStack, MediaWiki,
and LibreOffice. Written in Python, it uses Gerrit's SSH API.

=item * L<git-change|https://github.com/Nextdoor/git-change>

Simpler than git-review, git-change is well documented and has the best name
of all. From it, git-gerrit took the change-branch concept. Written in Python,
it uses Gerrit's SSH API.

=item * L<Barnum|http://barnum.gitblit.com/>

A newer tool which supports Gerrit's and L<Gitblit|http://gitblit.com/>'s
review workflow. Written in Java it uses Gerrit's REST API.

=item * L<querrit|https://gitorious.org/querrit/querrit>

A very simple tool to query Gerrit and make it easier to push changes.
Written in Python, it uses Gerrit's SSH API.

=back

If you're interested in Gerrit automation per se, you can take a look at the
L<Gerrit::REST> Perl module, which is used by C<git-gerrit> to interact with
Gerrit via it's REST API.

=head1 REPOSITORY

L<https://github.com/gnustavo/Gerrit-REST>
